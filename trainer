#!/usr/bin/env python3

import json
import random
import sys
import re

import kociemba # https://github.com/muodov/kociemba

from termcolor import colored

#             |************|
#             |*U0**U1**U2*|
#             |************|
#             |*U3**U4**U5*|
#             |************|
#             |*U6**U7**U8*|
#             |************|
# ************|************|************|************
# *L0**L1**L2*|*F0**F1**F2*|*R0**R1**R2*|*B0**B1**B2*
# ************|************|************|************
# *L3**L4**L5*|*F3**F4**F5*|*R3**R4**R5*|*B3**B4**B5*
# ************|************|************|************
# *L6**L7**L8*|*F6**F7**F8*|*R6**R7**R8*|*B6**B7**B8*
# ************|************|************|************
#             |************|
#             |*D0**D1**D2*|
#             |************|
#             |*D3**D4**D5*|
#             |************|
#             |*D6**D7**D8*|
#             |************|

# U0, U1, U2, U3, U4, U5, U6, U7, U8, R0, R1, R2, R3, R4, R5, R6, R7, R8, F0, F1, F2, F3, F4, F5, F6, F7, F8, D0, D1, D2, D3, D4, D5, D6, D7, D8, L0, L1, L2, L3, L4, L5, L6, L7, L8, B0, B1, B2, B3, B4, B5, B6, B7, B8.

class CubeState:
    def __init__(self):
        self._U = ['U']*9
        self._R = ['R']*9
        self._F = ['F']*9
        self._D = ['D']*9
        self._L = ['L']*9
        self._B = ['B']*9

    def state(self):
        return (''.join(self._U)
                + ''.join(self._R)
                + ''.join(self._F)
                + ''.join(self._D)
                + ''.join(self._L)
                + ''.join(self._B))

    def colored(self):
        U = self._U
        R = self._R
        F = self._F
        D = self._D
        L = self._L
        B = self._B
        text = ('   '+U[0]+U[1]+U[2]+'      ' + '\n' +
                '   '+U[3]+U[4]+U[5]+'      ' + '\n' +
                '   '+U[6]+U[7]+U[8]+'      ' + '\n' +
                L[0]+L[1]+L[2]+F[0]+F[1]+F[2]+R[0]+R[1]+R[2]+B[0]+B[1]+B[2] + '\n' +
                L[3]+L[4]+L[5]+F[3]+F[4]+F[5]+R[3]+R[4]+R[5]+B[3]+B[4]+B[5] + '\n' +
                L[6]+L[7]+L[8]+F[6]+F[7]+F[8]+R[6]+R[7]+R[8]+B[6]+B[7]+B[8] + '\n' +
                '   '+D[0]+D[1]+D[2]+'      ' + '\n' +
                '   '+D[3]+D[4]+D[5]+'      ' + '\n' +
                '   '+D[6]+D[7]+D[8]+'      ' + '\n')
        result = ''
        for c in text:
            if c == '\n':
                result += c
            elif c == ' ':
                result += c*2
            elif c == 'U':
                result += colored(c*2, 'yellow', 'on_yellow')
            elif c == 'F':
                result += colored(c*2, 'green', 'on_green')
            elif c == 'L':
                result += colored(c*2, 'red', 'on_red')
            elif c == 'R':
                result += colored(c*2, 'magenta', 'on_magenta')
            elif c == 'B':
                result += colored(c*2, 'blue', 'on_blue')
            elif c == 'D':
                result += colored(c*2, 'grey', 'on_grey')
            else:
                result += colored(c*2, 'red', 'on_red')
        return result

    @staticmethod
    def _rotate1(x):
        return [x[6], x[3], x[0], x[7], x[4], x[1], x[8], x[5], x[2]]

    @staticmethod
    def _rotate2(x):
        return CubeState._rotate1(CubeState._rotate1(x))

    @staticmethod
    def _rotate3(x):
        return CubeState._rotate1(CubeState._rotate1(CubeState._rotate1(x)))

    def U(self):
        self._U = CubeState._rotate1(self._U)

        Ltemp = [self._L[0], self._L[1], self._L[2]]
        self._L[0] = self._F[0]
        self._L[1] = self._F[1]
        self._L[2] = self._F[2]

        self._F[0] = self._R[0]
        self._F[1] = self._R[1]
        self._F[2] = self._R[2]

        self._R[0] = self._B[0]
        self._R[1] = self._B[1]
        self._R[2] = self._B[2]

        self._B[0] = Ltemp[0]
        self._B[1] = Ltemp[1]
        self._B[2] = Ltemp[2]

    def D(self):
        self._D = CubeState._rotate1(self._D)

        Ltemp = [self._L[6], self._L[7], self._L[8]]
        self._L[6] = self._B[6]
        self._L[7] = self._B[7]
        self._L[8] = self._B[8]

        self._B[6] = self._R[6]
        self._B[7] = self._R[7]
        self._B[8] = self._R[8]

        self._R[6] = self._F[6]
        self._R[7] = self._F[7]
        self._R[8] = self._F[8]

        self._F[6] = Ltemp[0]
        self._F[7] = Ltemp[1]
        self._F[8] = Ltemp[2]

    def R(self):
        self._R = CubeState._rotate1(self._R)

        Ftemp = [self._F[2], self._F[5], self._F[8]]
        self._F[2] = self._D[2]
        self._F[5] = self._D[5]
        self._F[8] = self._D[8]

        self._D[2] = self._B[6]
        self._D[5] = self._B[3]
        self._D[8] = self._B[0]

        self._B[6] = self._U[2]
        self._B[3] = self._U[5]
        self._B[0] = self._U[8]

        self._U[2] = Ftemp[0]
        self._U[5] = Ftemp[1]
        self._U[8] = Ftemp[2]

    def L(self):
        self._L = CubeState._rotate1(self._L)

        Ftemp = [self._F[0], self._F[3], self._F[6]]
        self._F[0] = self._U[0]
        self._F[3] = self._U[3]
        self._F[6] = self._U[6]

        self._U[0] = self._B[8]
        self._U[3] = self._B[5]
        self._U[6] = self._B[2]

        self._B[8] = self._D[0]
        self._B[5] = self._D[3]
        self._B[2] = self._D[6]

        self._D[0] = Ftemp[0]
        self._D[3] = Ftemp[1]
        self._D[6] = Ftemp[2]

    def F(self):
        self._F = CubeState._rotate1(self._F)

        Ltemp = [self._L[2], self._L[5], self._L[8]]
        self._L[2] = self._D[0]
        self._L[5] = self._D[1]
        self._L[8] = self._D[2]

        self._D[0] = self._R[6]
        self._D[1] = self._R[3]
        self._D[2] = self._R[0]

        self._R[6] = self._U[8]
        self._R[3] = self._U[7]
        self._R[0] = self._U[6]

        self._U[8] = Ltemp[0]
        self._U[7] = Ltemp[1]
        self._U[6] = Ltemp[2]

    def B(self):
        self._B = CubeState._rotate1(self._B)

        Ltemp = [self._L[0], self._L[3], self._L[6]]
        self._L[0] = self._U[2]
        self._L[3] = self._U[1]
        self._L[6] = self._U[0]

        self._U[2] = self._R[8]
        self._U[1] = self._R[5]
        self._U[0] = self._R[2]

        self._R[8] = self._D[6]
        self._R[5] = self._D[7]
        self._R[2] = self._D[8]

        self._D[6] = Ltemp[0]
        self._D[7] = Ltemp[1]
        self._D[8] = Ltemp[2]

    def scramble(self, moves):
        for m in re.split(r'[\s()\[\]]+', moves):
            if m == 'R':
                self.R()
            elif m == 'R2' or m == 'R2\'':
                self.R()
                self.R()
            elif m == 'R\'':
                self.R()
                self.R()
                self.R()

            elif m == 'L':
                self.L()
            elif m == 'L2' or m == 'L2\'':
                self.L()
                self.L()
            elif m == 'L\'':
                self.L()
                self.L()
                self.L()

            elif m == 'U':
                self.U()
            elif m == 'U2' or m == 'U2\'':
                self.U()
                self.U()
            elif m == 'U\'':
                self.U()
                self.U()
                self.U()

            elif m == 'D':
                self.D()
            elif m == 'D2' or m == 'D2\'':
                self.D()
                self.D()
            elif m == 'D\'':
                self.D()
                self.D()
                self.D()

            elif m == 'F':
                self.F()
            elif m == 'F2' or m == 'F2\'':
                self.F()
                self.F()
            elif m == 'F\'':
                self.F()
                self.F()
                self.F()

            elif m == 'B':
                self.B()
            elif m == 'B2' or m == 'B2\'':
                self.B()
                self.B()
            elif m == 'B\'':
                self.B()
                self.B()
                self.B()

            elif m == '':
                pass
            else:
                sys.stderr.write('unknown move %s\n' % m)
                exit(-1)


plls = [
    # EPLLs
    {
        'name': 'Ub (bar back)',
        'solution': "R2 U (R U R' U') R' U' (R' U R')",
    },
    {
        'name': 'Ub (bar front)',
        'solution': "(R' U R' U') R' U' (R' U R U) R2'",
    },
    {
        'name': 'Ua (bar back)',
        'solution': "(R U' R U) R U (R U' R' U') R2",
    },
    {
        'name': 'Ua (bar front)',
        'solution': "(R U R' U) (R' U' R2 U') R' U R' U R",
    },
    {
        'name': 'Z',
        'solution': "(R' U' R U' R U) (R U' R' U R U R2 U' R')",
    },
    {
        'name': 'H',
        'solution': "(R2 U2 R U2 R2) U2 (R2 U2 R U2 R2)",
    },
    # ECLLs
    {
        'name': 'Aa',
        'solution': "R' F R' B2 R F' R' B2 R2",
    },
    {
        'name': 'Ab',
        'solution': "R2' B2 (R F R') B2 (R F' R)",
    },
    {
        'name': 'E',
        'solution': "(R B' R' F) (R B R' F') (R B R' F) (R B' R' F')",
    },
    # adjacent corner swap + edge swap
    {
        'name': 'Ra',
        'solution': "(R U R' F') (R U2 R' U2') (R' F R U) (R U2' R') [U']",
    },
    {
        'name': 'Rb',
        'solution': "(R' U2 R U2) R' F (R U R' U') R' F' R2 [U']",
    },
    {
        'name': 'Ja',
        'solution': "(R' U L' U2) (R U' R' U2 R) L [U']",
    },
    {
        'name': 'Jb',
        'solution': "(R U R' F') (R U R' U') R' F R2 U' R' [U']",
    },
    {
        'name': 'T',
        'solution': "(R U R' U') (R' F R2 U') R' U' (R U R' F')",
    },
    {
        'name': 'F',
        'solution': "(R' U' F')(R U R' U')(R' F R2 U')(R' U' R U)(R' U R)",
    },
    # diagonal corner swap + edge swap
    {
        'name': 'V',
        'solution': "(F' U F' U') (R' F' R2 U') (R' U R' F) R F",
    },
    {
        'name': 'Y',
        'solution': "F (R U' R' U') (R U R' F') (R U R' U') (R' F R F')",
    },
    {
        'name': 'Na',
        'solution': "(R U R' U)(R U R' F')(R U R' U')(R' F R2 U') R' U2 (R U' R')",
    },
    {
        'name': 'Nb',
        'solution': "(R' U R U') (R' F' U' F) (R U R' F) R' F' (R U' R)",
    },
]

# to get a scramble for case X:
# get a solution for scramble: (solution for case X) (random pll)

cases = [
    {
        'name': 'WV - 3 corners - #1',
        'solution': "L' U2 (R U R') U2 L",
    },

    {
        'name': 'WV - 2 corners - #2 (FR pointing front)',
        'solution': "R U' R'",
    },
    {
        'name': 'WV - 2 corners - #3 (BR pointing back)',
        'comment': 'insert to Sune',
        'solution': "(R U' R') U [R' U' R U' R' U2 R]",
    },
    {
        'name': 'WV - 2 corners - #4 (BL pointing back)',
        'solution': "U' (R U' R' U2) (R U' R' U2) (R U R')",
    },
    {
        'name': 'WV - 2 corners - #5 (FR pointing right)',
        'solution': "U' (R' F R U) (R U' R' F')",
    },
    {
        'name': 'WV - 2 corners - #6 (BR pointing right)',
        'solution': "R2 D R' U' R D' R2'",
    },
    {
        'name': 'WV - 2 corners - #7 (BL pointing left)',
        'solution': "(R U R' U') (R U' R')",
    },

    {
        'name': 'WV - 1 corner - #8 (BL pointing back, BR pointing right)',
        'solution': "U (R U' R' U) (R U2' R')"
    },
    {
        'name': 'WV - 1 corner - #9 (BL pointing back, BR pointing back)',
        'comment': 'insert to Sune',
        'solution': "U (R U2' R') U' [R U R' U R U2' R']",
    },
    {
        'name': 'WV - 1 corner - #10 (BL pointing back, FR pointing front)',
        'comment': 'insert to OLL',
        'solution': "(R U' R') -> [OLL]",
    },
    {
        'name': 'WV - 1 corner - #11 (BL pointing back, FR pointing right)',
        'comment': 'insert to Sune',
        'solution': "(R U' R') U2 [R U R' U R U2' R']",
    },
    {
        'name': 'WV - 1 corner - #12 (BL pointing left, BR pointing back)',
        'comment': 'insert to Sune',
        'solution': "(R U' R') U' [R U2 R' U' R U' R']",
    },
    {
        'name': 'WV - 1 corner - #13 (BL pointing left, BR pointing right)',
        'solution': "U F' (R U2' R' U2) R' F R",
    },
    {
        'name': 'WV - 1 corner - #14 (BL pointing left, FR pointing front)',
        'comment': 'insert to Sune',
        'solution': "U R U2' [R2' U' R U' R' U2 R]",
    },
    {
        'name': 'WV - 1 corner - #15 (BL pointing left, FR pointing right)',
        'solution': "U' L' (U R U' R') L",
    },
    {
        'name': 'WV - 1 corner - #16 (BR pointing back, FR pointing front)',
        'comment': 'insert to OLL',
        'solution': "(R U' R') -> [OLL]",
    },
    {
        'name': 'WV - 1 corner - #17 (BL pointing back, FR pointing right)',
        'comment': 'insert to OLL',
        'solution': "(R U' R') -> [OLL]",
    },
    {
        'name': 'WV - 1 corner - #18 (BL pointing right, FR pointing front)',
        'comment': 'insert to OLL',
        'solution': "(R U' R') -> [OLL]",
    },
    {
        'name': 'WV - 1 corner - #19 (BL pointing right, FR pointing right)',
        'solution': "U R U2' R'",
    },
]

enabled_cases = [cases[0], cases[1], cases[3], cases[4], cases[6], cases[18]]

while True:
    # to get a scramble for case X:
    # get a solution for inverse scramble: (solution for case X) (random pll)

    idx = random.randrange(len(enabled_cases))
    case = enabled_cases[idx]
    inv = CubeState()
    pll = plls[random.randrange(len(plls))]
    inv.scramble(case['solution'] + ' ' + pll['solution'])
    scramble = kociemba.solve(inv.state())
    print('\nscramble: %s' % scramble)
    fwd = CubeState()
    fwd.scramble(scramble)
    print(fwd.colored())
    print('? ', end='')
    sys.stdout.flush()
    action = sys.stdin.readline()
    print('case was %s' % json.dumps(case, indent=2))
    print('pll was %s' % json.dumps(pll, indent=2))
