#!/usr/bin/env python3

import json
import random
import sys
import re

import kociemba # https://github.com/muodov/kociemba

from termcolor import colored

#             |************|
#             |*U0**U1**U2*|
#             |************|
#             |*U3**U4**U5*|
#             |************|
#             |*U6**U7**U8*|
#             |************|
# ************|************|************|************
# *L0**L1**L2*|*F0**F1**F2*|*R0**R1**R2*|*B0**B1**B2*
# ************|************|************|************
# *L3**L4**L5*|*F3**F4**F5*|*R3**R4**R5*|*B3**B4**B5*
# ************|************|************|************
# *L6**L7**L8*|*F6**F7**F8*|*R6**R7**R8*|*B6**B7**B8*
# ************|************|************|************
#             |************|
#             |*D0**D1**D2*|
#             |************|
#             |*D3**D4**D5*|
#             |************|
#             |*D6**D7**D8*|
#             |************|

# U0, U1, U2, U3, U4, U5, U6, U7, U8, R0, R1, R2, R3, R4, R5, R6, R7, R8, F0, F1, F2, F3, F4, F5, F6, F7, F8, D0, D1, D2, D3, D4, D5, D6, D7, D8, L0, L1, L2, L3, L4, L5, L6, L7, L8, B0, B1, B2, B3, B4, B5, B6, B7, B8.

class CubeState:
    def __init__(self):
        self._U = ['U0', 'U1', 'U2', 'U3', 'U4', 'U5', 'U6', 'U7', 'U8']
        self._R = ['R0', 'R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8']
        self._F = ['F0', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8']
        self._D = ['D0', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8']
        self._L = ['L0', 'L1', 'L2', 'L3', 'L4', 'L5', 'L6', 'L7', 'L8']
        self._B = ['B0', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8']

    def state(self):
        return (''.join(map(lambda x: x[0], self._U))
                + ''.join(map(lambda x: x[0], self._R))
                + ''.join(map(lambda x: x[0], self._F))
                + ''.join(map(lambda x: x[0], self._D))
                + ''.join(map(lambda x: x[0], self._L))
                + ''.join(map(lambda x: x[0], self._B)))

    def colored(self):
        U = self._U
        R = self._R
        F = self._F
        D = self._D
        L = self._L
        B = self._B
        text = [' ' ,' ' ,' ' ,U[0],U[1],U[2],' ' ,' ' ,' ' ,' ' ,' ' ,' ' , '\n',
                ' ' ,' ' ,' ' ,U[3],U[4],U[5],' ' ,' ' ,' ' ,' ' ,' ' ,' ' , '\n',
                ' ' ,' ' ,' ' ,U[6],U[7],U[8],' ' ,' ' ,' ' ,' ' ,' ' ,' ' , '\n',
                L[0],L[1],L[2],F[0],F[1],F[2],R[0],R[1],R[2],B[0],B[1],B[2], '\n',
                L[3],L[4],L[5],F[3],F[4],F[5],R[3],R[4],R[5],B[3],B[4],B[5], '\n',
                L[6],L[7],L[8],F[6],F[7],F[8],R[6],R[7],R[8],B[6],B[7],B[8], '\n',
                ' ' ,' ' ,' ' ,D[0],D[1],D[2],' ' ,' ' ,' ' ,' ' ,' ' ,' ' , '\n',
                ' ' ,' ' ,' ' ,D[3],D[4],D[5],' ' ,' ' ,' ' ,' ' ,' ' ,' ' , '\n',
                ' ' ,' ' ,' ' ,D[6],D[7],D[8],' ' ,' ' ,' ' ,' ' ,' ' ,' ' , '\n']
        result = ''
        debug = False
        for c in text:
            if c == '\n':
                result += c
            elif c == ' ':
                result += c*2
            elif c.startswith('U'):
                result += colored('%2s' % c, 'white' if debug else 'yellow', 'on_yellow')
            elif c.startswith('F'):
                result += colored('%2s' % c, 'white' if debug else 'green', 'on_green')
            elif c.startswith('L'):
                result += colored('%2s' % c, 'white' if debug else 'red', 'on_red')
            elif c.startswith('R'):
                result += colored('%2s' % c, 'white' if debug else 'magenta', 'on_magenta')
            elif c.startswith('B'):
                result += colored('%2s' % c, 'white' if debug else 'blue', 'on_blue')
            elif c.startswith('D'):
                result += colored('%2s' % c, 'white' if debug else 'grey', 'on_grey')
            else:
                result += colored('%2s' % c, 'white' if debug else 'red', 'on_red')
        return result

    @staticmethod
    def _rotate1(x):
        return [x[6], x[3], x[0], x[7], x[4], x[1], x[8], x[5], x[2]]

    @staticmethod
    def _rotate2(x):
        return CubeState._rotate1(CubeState._rotate1(x))

    @staticmethod
    def _rotate3(x):
        return CubeState._rotate1(CubeState._rotate1(CubeState._rotate1(x)))

    def X(self):
        self._R = CubeState._rotate1(self._R)
        self._L = CubeState._rotate3(self._L)
        Utemp = self._U
        self._U = self._F
        self._F = self._D
        self._D = CubeState._rotate2(self._B)
        self._B = CubeState._rotate2(Utemp)

        return self

    def Y(self):
        self._U = CubeState._rotate1(self._U)
        self._D = CubeState._rotate3(self._D)
        Ftemp = self._F
        self._F = self._R
        self._R = self._B
        self._B = self._L
        self._L = Ftemp

        return self

    def Z(self):
        self._F = CubeState._rotate1(self._F)
        self._B = CubeState._rotate3(self._B)
        Utemp = self._U
        self._U = CubeState._rotate1(self._L)
        self._L = CubeState._rotate1(self._D)
        self._D = CubeState._rotate1(self._R)
        self._R = CubeState._rotate1(Utemp)

        return self

    def U(self):
        self._U = CubeState._rotate1(self._U)

        Ltemp = [self._L[0], self._L[1], self._L[2]]
        self._L[0] = self._F[0]
        self._L[1] = self._F[1]
        self._L[2] = self._F[2]

        self._F[0] = self._R[0]
        self._F[1] = self._R[1]
        self._F[2] = self._R[2]

        self._R[0] = self._B[0]
        self._R[1] = self._B[1]
        self._R[2] = self._B[2]

        self._B[0] = Ltemp[0]
        self._B[1] = Ltemp[1]
        self._B[2] = Ltemp[2]

        return self

    def D(self):
        self._D = CubeState._rotate1(self._D)

        Ltemp = [self._L[6], self._L[7], self._L[8]]
        self._L[6] = self._B[6]
        self._L[7] = self._B[7]
        self._L[8] = self._B[8]

        self._B[6] = self._R[6]
        self._B[7] = self._R[7]
        self._B[8] = self._R[8]

        self._R[6] = self._F[6]
        self._R[7] = self._F[7]
        self._R[8] = self._F[8]

        self._F[6] = Ltemp[0]
        self._F[7] = Ltemp[1]
        self._F[8] = Ltemp[2]

        return self

    def R(self):
        self._R = CubeState._rotate1(self._R)

        Ftemp = [self._F[2], self._F[5], self._F[8]]
        self._F[2] = self._D[2]
        self._F[5] = self._D[5]
        self._F[8] = self._D[8]

        self._D[2] = self._B[6]
        self._D[5] = self._B[3]
        self._D[8] = self._B[0]

        self._B[6] = self._U[2]
        self._B[3] = self._U[5]
        self._B[0] = self._U[8]

        self._U[2] = Ftemp[0]
        self._U[5] = Ftemp[1]
        self._U[8] = Ftemp[2]

        return self

    def L(self):
        self._L = CubeState._rotate1(self._L)

        Ftemp = [self._F[0], self._F[3], self._F[6]]
        self._F[0] = self._U[0]
        self._F[3] = self._U[3]
        self._F[6] = self._U[6]

        self._U[0] = self._B[8]
        self._U[3] = self._B[5]
        self._U[6] = self._B[2]

        self._B[8] = self._D[0]
        self._B[5] = self._D[3]
        self._B[2] = self._D[6]

        self._D[0] = Ftemp[0]
        self._D[3] = Ftemp[1]
        self._D[6] = Ftemp[2]

        return self

    def F(self):
        self._F = CubeState._rotate1(self._F)

        Ltemp = [self._L[2], self._L[5], self._L[8]]
        self._L[2] = self._D[0]
        self._L[5] = self._D[1]
        self._L[8] = self._D[2]

        self._D[0] = self._R[6]
        self._D[1] = self._R[3]
        self._D[2] = self._R[0]

        self._R[6] = self._U[8]
        self._R[3] = self._U[7]
        self._R[0] = self._U[6]

        self._U[8] = Ltemp[0]
        self._U[7] = Ltemp[1]
        self._U[6] = Ltemp[2]

        return self

    def B(self):
        self._B = CubeState._rotate1(self._B)

        Ltemp = [self._L[0], self._L[3], self._L[6]]
        self._L[0] = self._U[2]
        self._L[3] = self._U[1]
        self._L[6] = self._U[0]

        self._U[2] = self._R[8]
        self._U[1] = self._R[5]
        self._U[0] = self._R[2]

        self._R[8] = self._D[6]
        self._R[5] = self._D[7]
        self._R[2] = self._D[8]

        self._D[6] = Ltemp[0]
        self._D[7] = Ltemp[1]
        self._D[8] = Ltemp[2]

        return self

    def M(self):
        return self.X().X().X().R().L().L().L()

    def Mi(self):
        return self.X().R().R().R().L()

    def r(self):
        return self.X().L()

    def ri(self):
        return self.X().X().X().L().L().L()

    def scramble(self, moves):
        for m in re.split(r'[\s()\[\]]+', moves):
            if m == 'R':
                self.R()
            elif m == 'R2' or m == 'R2\'':
                self.R()
                self.R()
            elif m == 'R\'':
                self.R()
                self.R()
                self.R()

            elif m == 'L':
                self.L()
            elif m == 'L2' or m == 'L2\'':
                self.L()
                self.L()
            elif m == 'L\'':
                self.L()
                self.L()
                self.L()

            elif m == 'U':
                self.U()
            elif m == 'U2' or m == 'U2\'':
                self.U()
                self.U()
            elif m == 'U\'':
                self.U()
                self.U()
                self.U()

            elif m == 'D':
                self.D()
            elif m == 'D2' or m == 'D2\'':
                self.D()
                self.D()
            elif m == 'D\'':
                self.D()
                self.D()
                self.D()

            elif m == 'F':
                self.F()
            elif m == 'F2' or m == 'F2\'':
                self.F()
                self.F()
            elif m == 'F\'':
                self.F()
                self.F()
                self.F()

            elif m == 'B':
                self.B()
            elif m == 'B2' or m == 'B2\'':
                self.B()
                self.B()
            elif m == 'B\'':
                self.B()
                self.B()
                self.B()

            elif m == 'M':
                self.M()
            elif m == 'M\'':
                self.Mi()

            elif m == 'r':
                self.r()
            elif m == 'r\'':
                self.ri()

            elif m == '':
                pass
            else:
                sys.stderr.write('unknown move %s\n' % m)
                exit(-1)


plls = [
    # EPLLs
    {
        'name': 'Ub (bar back)',
        'solution': "R2 U (R U R' U') R' U' (R' U R')",
    },
    {
        'name': 'Ub (bar front)',
        'solution': "(R' U R' U') R' U' (R' U R U) R2'",
    },
    {
        'name': 'Ua (bar back)',
        'solution': "(R U' R U) R U (R U' R' U') R2",
    },
    {
        'name': 'Ua (bar front)',
        'solution': "(R U R' U) (R' U' R2 U') R' U R' U R",
    },
    {
        'name': 'Z',
        'solution': "(R' U' R U' R U) (R U' R' U R U R2 U' R')",
    },
    {
        'name': 'H',
        'solution': "(R2 U2 R U2 R2) U2 (R2 U2 R U2 R2)",
    },
    # ECLLs
    {
        'name': 'Aa',
        'solution': "R' F R' B2 R F' R' B2 R2",
    },
    {
        'name': 'Ab',
        'solution': "R2' B2 (R F R') B2 (R F' R)",
    },
    {
        'name': 'E',
        'solution': "(R B' R' F) (R B R' F') (R B R' F) (R B' R' F')",
    },
    # adjacent corner swap + edge swap
    {
        'name': 'Ra',
        'solution': "(R U R' F') (R U2 R' U2') (R' F R U) (R U2' R') [U']",
    },
    {
        'name': 'Rb',
        'solution': "(R' U2 R U2) R' F (R U R' U') R' F' R2 [U']",
    },
    {
        'name': 'Ja',
        'solution': "(R' U L' U2) (R U' R' U2 R) L [U']",
    },
    {
        'name': 'Jb',
        'solution': "(R U R' F') (R U R' U') R' F R2 U' R' [U']",
    },
    {
        'name': 'T',
        'solution': "(R U R' U') (R' F R2 U') R' U' (R U R' F')",
    },
    {
        'name': 'F',
        'solution': "(R' U' F')(R U R' U')(R' F R2 U')(R' U' R U)(R' U R)",
    },
    # diagonal corner swap + edge swap
    {
        'name': 'V',
        'solution': "(F' U F' U') (R' F' R2 U') (R' U R' F) R F",
    },
    {
        'name': 'Y',
        'solution': "F (R U' R' U') (R U R' F') (R U R' U') (R' F R F')",
    },
    {
        'name': 'Na',
        'solution': "(R U R' U)(R U R' F')(R U R' U')(R' F R2 U') R' U2 (R U' R')",
    },
    {
        'name': 'Nb',
        'solution': "(R' U R U') (R' F' U' F) (R U R' F) R' F' (R U' R)",
    },
]

# to get a scramble for case X:
# get a solution for scramble: (solution for case X) (random pll)

cases = [
    {
        'name': 'WV - 3 corners - #1',
        'comment': 'skips bow-tie',
        'solution': "L' U2 (R U R') U2 L",
    },

    {
        'name': 'WV - 2 corners - #2 (FR pointing front)',
        'comment': 'normal insert',
        'solution': "R U' R'",
    },
    {
        'name': 'WV - 2 corners - #3 (BR pointing back)',
        'comment': 'insert to back anti-sune',
        'solution': "(R U' R') U [R' U' R U' R' U2 R]",
    },
    {
        'name': 'WV - 2 corners - #4 (BL pointing back)',
        'comment': 'skips headlights',
        'solution': "U' (R U' R' U2) (R U' R' U2) (R U R')",
    },
    {
        'name': 'WV - 2 corners - #5 (FR pointing right)',
        'comment': 'skips bow-tie',
        'solution': "U' (R' F R U) (R U' R' F')",
    },
    {
        'name': 'WV - 2 corners - #6 (BR pointing right)',
        'comment': 'skips chameleon',
        'solution': "R2 D R' U' R D' R2'",
    },
    {
        'name': 'WV - 2 corners - #7 (BL pointing left)',
        'comment': 'skips anti-sune',
        'solution': "(R U R' U') (R U' R')",
    },

    {
        'name': 'WV - 1 corner - #8 (BL pointing back, BR pointing right)',
        'comment': 'skips double-sune',
        'solution': "(U R U' R') U (R U2' R')"
    },
    {
        'name': 'WV - 1 corner - #9 (BL pointing back, BR pointing back)',
        'comment': 'U2 insert to sune - skips pi',
        'solution': "U (R U2' R') U' [R U R' U R U2' R']",
    },
    {
        'name': 'WV - 1 corner - #10 (BL pointing back, FR pointing front)',
        'comment': 'insert to OLL (chameleon)',
        'solution': "(R U' R') U [(L F R' F') (L' F R F')]",
    },
    {
        'name': 'WV - 1 corner - #11 (BL pointing back, FR pointing right)',
        'comment': 'insert to sune',
        'solution': "(R U' R') U2 [R U R' U R U2' R']",
    },
    {
        'name': 'WV - 1 corner - #12 (BL pointing left, BR pointing back)',
        'comment': 'insert to anti-Sune',
        'solution': "(R U' R') U' [R U2 R' U' R U' R']",
    },
    {
        'name': 'WV - 1 corner - #13 (BL pointing left, BR pointing right)',
        'comment': 'skips pi',
        'solution': "U F' (R U2' R' U2) R' F R",
    },
    {
        'name': 'WV - 1 corner - #14 (BL pointing left, FR pointing front)',
        'comment': 'U2 insert to back anti-aune - skips headlights',
        'solution': "U R U2' [R2' U' R U' R' U2 R]",
    },
    {
        'name': 'WV - 1 corner - #15 (BL pointing left, FR pointing right)',
        'comment': 'skips chameleon',
        'solution': "U' L' (U R U' R') L",
    },
    {
        'name': 'WV - 1 corner - #16 (BR pointing back, FR pointing front)',
        'comment': 'insert to OLL (chameleon)',
        'solution': "(R U' R') U2 [(L F R' F') (L' F R F')]",
    },
    {
        'name': 'WV - 1 corner - #17 (BL pointing back, FR pointing right)',
        'comment': 'insert to OLL (headlights)',
        'solution': "(R U' R') U2 [R2 D (R' U2 R) D' (R' U2 R')]",
    },
    {
        'name': 'WV - 1 corner - #18 (BL pointing right, FR pointing front)',
        'comment': 'insert to OLL (headlights)',
        'solution': "(R U' R') U [R2 D (R' U2 R) D' (R' U2 R')]",
    },
    {
        'name': 'WV - 1 corner - #19 (BL pointing right, FR pointing right)',
        'comment': 'skips sune',
        'solution': "U R U2' R'",
    },

    {
        'name': 'WV - 0 corners - #20 (BL pointing back, BR pointing right, FR pointing front)',
        'comment': 'insert to sune',
        'solution': "(R U' R') U' [R U R' U R U2' R']",
    },
    {
        'name': 'WV - 0 corners - #21 (BL pointing back, BR pointing right, FR pointing right)',
        'comment': 'insert to back sune',
        'solution': "R U' [R2' U2' R U R' U R]",
    },
    {
        'name': 'WV - 0 corners - #22 (BL pointing back, BR pointing back, FR pointing front)',
        'comment': 'skips bowtie',
        'solution': "(U R U' R') (U (R U' R') U R U2' R'",
    },
    {
        'name': 'WV - 0 corners - #23 (BL pointing back, BR pointing back, FR pointing right)',
        'comment': 'U2 insert to back sune - skips pi',
        'solution': "U R U2' [R2' U2' R U R' U R]",
    },
    {
        'name': 'WV - 0 corners - #24 (BL pointing left, BR pointing back, FR pointing front)',
        'comment': 'insert to back anti-sune',
        'solution': "R U' [R2' U' R U' R' U2 R]",
    },
    {
        'name': 'WV - 0 corners - #25 (BL pointing left, BR pointing back, FR pointing right)',
        'comment': 'skips double sune',
        'solution': "(R U R' U') (R U R' U') R U' R'",
    },
    {
        'name': 'WV - 0 corners - #26 (BL pointing left, BR pointing right, FR pointing front)',
        'comment': 'skips bowtie',
        'solution': "R2 D R' U R D' R' U2 R'",
    },
    {
        'name': 'WV - 0 corners - #27 (BL pointing left, BR pointing right, FR pointing right)',
        'comment': 'insert to OLL (pi)',
        'solution': "(R U' R') U2 [R U2' R2' U' R2 U' R2' U2' R]",
    },

    {
        'name': 'VLS - UF misoriented + 2 corners (BR pointing right)',
        'comment': 'test',
        'solution': "M' (U R U' r')",
    },
    {
        'name': 'VLS - UF misoriented + 1 corners (FL pointing front, BR pointing back)',
        'comment': 'test',
        'solution': "R' F R F'",
    },
]

enabled_cases = [
    cases[0],
    cases[1],
    cases[2],
    cases[3],
    cases[4],
    cases[5],
    cases[6],
    cases[7],
    cases[8],
    cases[9],
    cases[18],
    cases[27],
    cases[28],
]
others = [
]

aufs = [ '', 'U', 'U\'', 'U2' ]

while True:
    # to get a scramble for case X:
    # get a solution for inverse scramble: (solution for case X) (random pll)
    print('training %d of %d cases' % (len(enabled_cases), len(cases)))

    idx = random.randrange(len(enabled_cases))
    case = enabled_cases[idx]
    inv = CubeState()
    pll = plls[random.randrange(len(plls))]
    auf1 = aufs[random.randrange(len(aufs))]
    auf2 = aufs[random.randrange(len(aufs))]
    auf3 = aufs[random.randrange(len(aufs))]
    inv.scramble(auf1 + ' ' + case['solution'] + ' ' + auf2 + ' ' + pll['solution'] + ' ' + auf3)
    scramble = kociemba.solve(inv.state())
    print('\nscramble: %s' % scramble)
    fwd = CubeState()
    fwd.scramble(scramble)
    print(fwd.colored())
    print('? ', end='')
    sys.stdout.flush()
    action = sys.stdin.readline()
    print('auf1 was %s' % auf1)
    print('case was %s' % json.dumps(case, indent=2))
    print('auf2 was %s' % auf2)
    print('pll was %s' % json.dumps(pll, indent=2))
    print('auf3 was %s' % auf3)
